// StabilizerChain.cpp

#include "StabilizerChain.h"
#include <memory>

//------------------------------------------------------------------------------------------
//                                   StabilizerChainGroup
//------------------------------------------------------------------------------------------

StabilizerChainGroup::StabilizerChainGroup( void )
{
	subGroup = nullptr;

	stabilizerPoint = 0;
}

StabilizerChainGroup::~StabilizerChainGroup( void )
{
	delete subGroup;
}

void StabilizerChainGroup::Print( std::ostream& ostream, uint flags /*= PRINT_FLAG_REPRESENTATIVES*/ ) const
{
	ostream << "==================================================================\n";
	ostream << "Stabilizer point for subgroup is: " << stabilizerPoint << "\n";

	if( flags & PRINT_FLAG_GENERATORS )
	{
		ostream << "--------------------------------------------\n";
		ostream << "Generators...\n";
		for( PermutationSet::const_iterator iter = generatorSet.cbegin(); iter != generatorSet.cend(); iter++ )
			( *iter ).Print( ostream );
	}

	if( flags & PRINT_FLAG_REPRESENTATIVES )
	{
		ostream << "--------------------------------------------\n";
		ostream << "Coset representatives...\n";
		for( PermutationSet::const_iterator iter = transversalSet.cbegin(); iter != transversalSet.cend(); iter++ )
			( *iter ).Print( ostream );
	}

	if( subGroup )
		subGroup->Print( ostream, flags );
}

// The order in which we stabilize points may have an impact on the size of the factorizations in the chain.
bool StabilizerChainGroup::Generate( uint* pointArray, uint pointArraySize, uint pointArrayOffset, std::ostream* ostream /*= nullptr*/ )
{
	if( generatorSet.size() == 1 )
	{
		PermutationSet::iterator iter = generatorSet.begin();
		const Permutation& permutation = *iter;
		if( permutation.IsIdentity() )
		{
			if( ostream )
				*ostream << "Process complete!\n";

			return true;
		}
	}

	if( pointArrayOffset >= pointArraySize )
		return false;

	stabilizerPoint = pointArray[ pointArrayOffset ];

	if( ostream )
	{
		*ostream << "Calculating orbits of " << stabilizerPoint << " in group generated by...\n";
		
		for( PermutationSet::iterator iter = generatorSet.begin(); iter != generatorSet.end(); iter++ )
			( *iter ).Print( *ostream );

		*ostream << "Total generators: " << generatorSet.size() << "\n";
	}

	NaturalNumberSet orbitSet;

	PermutationSet permutationQueue;
	Permutation identity;
	identity.word = new ElementList;
	permutationQueue.insert( identity );

	// Notice that the identity element will always land in the traversal.
	// This is a requirement of Schreier's lemma.
	while( permutationQueue.size() > 0 )
	{
		PermutationSet::iterator iter = permutationQueue.begin();
		Permutation permutation = *iter;
		permutationQueue.erase( iter );

		uint point = permutation.Evaluate( stabilizerPoint );
		if( !orbitSet.IsMember( point ) )
		{
			if( ostream )
			{
				*ostream << "Found new orbit: " << point << "\n";
				*ostream << "Coset representative: ";
				permutation.Print( *ostream );
			}

			orbitSet.AddMember( point );
			
			// This is the orbit-stabilizer theorem!
			transversalSet.insert( permutation );

			EnqueueNewPermutations( permutation, permutationQueue );
		}
	}

	if( ostream )
		*ostream << "Calculating Schreier generators...\n";

	subGroup = new StabilizerChainGroup();

	if( !CalculateSchreierGenerators( subGroup->generatorSet ) )
		return false;

	if( !subGroup->Generate( pointArray, pointArraySize, pointArrayOffset + 1, ostream ) )
		return false;
	
	return true;
}

bool StabilizerChainGroup::CalculateSchreierGenerators( PermutationSet& schreierGeneratorSet )
{
	for( PermutationSet::iterator genIter = generatorSet.begin(); genIter != generatorSet.end(); genIter++ )
	{
		const Permutation& generator = *genIter;

		for( PermutationSet::iterator transIter = transversalSet.begin(); transIter != transversalSet.end(); transIter++ )
		{
			const Permutation& cosetRepresentative = *transIter;

			Permutation product;
			product.Multiply( generator, cosetRepresentative );

			PermutationSet::iterator iter = FindCoset( product );
			if( iter == transversalSet.end() )
				return false;		// Something went wrong with our math!

			Permutation invCosetRepresentative;
			invCosetRepresentative.SetInverse( *iter );

			Permutation newGenerator;
			newGenerator.Multiply( product, invCosetRepresentative );

			schreierGeneratorSet.insert( newGenerator );
		}
	}

	return true;
}

PermutationSet::iterator StabilizerChainGroup::FindCoset( const Permutation& permutation )
{
	Permutation invPermutation;
	invPermutation.SetInverse( permutation );

	PermutationSet::iterator iter = transversalSet.begin();
	while( iter != transversalSet.end() )
	{
		const Permutation& cosetRepresentative = *iter;

		Permutation product;
		product.Multiply( cosetRepresentative, invPermutation );

		uint point = product.Evaluate( stabilizerPoint );
		if( point == stabilizerPoint )
			break;

		iter++;
	}

	return iter;
}

// This may be the naive approach to what Minkwitz describes in his paper.
bool StabilizerChainGroup::Optimize( std::ostream* ostream /*= nullptr*/ )
{
	// We might consider calling the OptimizeWithPermutation function with
	// permutations we know are useful, such as a bunch of conjugates that
	// setup to a certain depth, or conjugates of commutators, etc.

	PermutationSet processedSet;
	PermutationSet permutationQueue;
	Permutation identity;
	identity.word = new ElementList;
	permutationQueue.insert( identity );

	while( permutationQueue.size() > 0 )
	{
		PermutationSet::iterator iter = permutationQueue.begin();
		Permutation permutation = *iter;
		permutationQueue.erase( iter );

		if( ostream )
		{
			*ostream << "Trying...\n";
			permutation.Print( *ostream );
		}

		OptimizeWithPermutation( permutation, ostream );

		processedSet.insert( permutation );
		EnqueueNewPermutations( permutation, permutationQueue, &processedSet );
	}

	return true;
}

bool StabilizerChainGroup::OptimizeWithPermutation( const Permutation& permutation, std::ostream* ostream /*= nullptr*/ )
{
	if( !subGroup )
		return false;

	if( permutation.Evaluate( stabilizerPoint ) == stabilizerPoint )
		return subGroup->OptimizeWithPermutation( permutation, ostream );

	PermutationSet::iterator iter = FindCoset( permutation );
	if( iter == transversalSet.end() )
		return false;

	const Permutation& cosetRepresentative = *iter;

	if( permutation.word->size() < cosetRepresentative.word->size() )
	{
		if( ostream )
		{
			*ostream << "Replacing...\n";
			cosetRepresentative.Print( *ostream );
			*ostream << "...with...\n";
			permutation.Print( *ostream );
		}

		transversalSet.erase( iter );
		transversalSet.insert( permutation );
		return true;
	}

	Permutation invPermutation;
	permutation.GetInverse( invPermutation );

	Permutation product;
	product.Multiply( cosetRepresentative, invPermutation );

	return subGroup->OptimizeWithPermutation( product, ostream );
}

void StabilizerChainGroup::EnqueueNewPermutations( const Permutation& permutation, PermutationSet& permutationQueue, PermutationSet* processedSet /*= nullptr*/ )
{
	for( PermutationSet::iterator iter = generatorSet.begin(); iter != generatorSet.end(); iter++ )
	{
		const Permutation& generator = *iter;

		Permutation newPermutation;
		newPermutation.Multiply( permutation, generator );

		if( !processedSet || processedSet->find( newPermutation ) == processedSet->end() )
		{
			if( permutationQueue.find( newPermutation ) == permutationQueue.end() )
				permutationQueue.insert( newPermutation );
		}
	}
}

// StabilizerChain.cpp