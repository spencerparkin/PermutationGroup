// StabilizerChain.cpp

#include "StabilizerChain.h"
#include <memory>

//------------------------------------------------------------------------------------------
//                                   StabilizerChainGroup
//------------------------------------------------------------------------------------------

StabilizerChainGroup::StabilizerChainGroup( void )
{
	subGroup = nullptr;

	stabilizerPoint = 0;
}

StabilizerChainGroup::~StabilizerChainGroup( void )
{
	delete subGroup;
}

bool StabilizerChainGroup::Generate( std::ostream* ostream /*= nullptr*/ )
{
	if( generatorSet.size() == 0 )
	{
		PermutationSet::iterator iter = generatorSet.begin();
		const Permutation& permutation = *iter;
		if( permutation.IsIdentity() )
			return true;
	}

	if( ostream )
	{
		*ostream << "Calculating orbits of " << stabilizerPoint << " in group generated by...\n";
		
		for( PermutationSet::iterator iter = generatorSet.begin(); iter != generatorSet.end(); iter++ )
			( *iter ).Print( *ostream );

		*ostream << "Total generators: " << generatorSet.size() << "\n";
	}

	NaturalNumberSet orbitSet;

	PermutationSet permutationQueue;
	Permutation identity;
	permutationQueue.insert( identity );

	// Notice that the identity element will always land in the traversal.
	// This is a requirement of Schreier's lemma.
	while( permutationQueue.size() > 0 )
	{
		if( ostream )
			*ostream << "Queue size: " << permutationQueue.size() << "\n";

		PermutationSet::iterator iter = permutationQueue.begin();
		Permutation permutation = *iter;
		permutationQueue.erase( iter );

		uint point = permutation.Evaluate( stabilizerPoint );
		if( !orbitSet.IsMember( point ) )
		{
			if( ostream )
				*ostream << "Found new orbit: " << point << "\n";

			orbitSet.AddMember( point );
			
			// This is the orbit-stabilizer theorem!
			transversalSet.insert( permutation );

			for( iter = generatorSet.begin(); iter != generatorSet.end(); iter++ )
			{
				const Permutation& generator = *iter;

				Permutation newPermutation;
				newPermutation.Multiply( permutation, generator );

				if( permutationQueue.find( newPermutation ) == permutationQueue.end() )
					permutationQueue.insert( newPermutation );
			}
		}
	}

	if( ostream )
	{
		*ostream << "Queue empty!\n";
		*ostream << "Calculating Schreier generators...\n";
	}

	subGroup = new StabilizerChainGroup();
	subGroup->stabilizerPoint = stabilizerPoint + 1;

	for( PermutationSet::iterator genIter = generatorSet.begin(); genIter != generatorSet.end(); genIter++ )
	{
		const Permutation& generator = *genIter;

		for( PermutationSet::iterator transIter = transversalSet.begin(); transIter != transversalSet.end(); transIter++ )
		{
			const Permutation& cosetRepresentative = *transIter;

			Permutation product;
			product.Multiply( generator, cosetRepresentative );

			PermutationSet::iterator iter = FindCoset( product );
			if( iter == transversalSet.end() )
				return false;		// Something went wrong with our math!

			Permutation newGenerator;
			newGenerator.Multiply( product, *iter );

			subGroup->generatorSet.insert( newGenerator );
		}
	}

	if( !subGroup->Generate( ostream ) )
		return false;
	
	return true;
}

PermutationSet::iterator StabilizerChainGroup::FindCoset( const Permutation& permutation )
{
	Permutation invPermutation;
	invPermutation.SetInverse( permutation );

	PermutationSet::iterator iter = transversalSet.begin();
	while( iter != transversalSet.end() )
	{
		const Permutation& cosetRepresentative = *iter;

		Permutation product;
		product.Multiply( cosetRepresentative, invPermutation );

		uint point = product.Evaluate( stabilizerPoint );
		if( point == stabilizerPoint )
			break;

		iter++;
	}

	return iter;
}

// StabilizerChain.cpp